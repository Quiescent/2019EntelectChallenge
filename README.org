* 2019 Entelect Challenge
This is my submission to the 2019 Entelect Challenge.

* Getting Started
Haskell is a purely functional programming language.  You can find out
more about Haskell [here](https://www.haskell.org/).

** Environment Requirements
Install the [[https://www.haskell.org/platform/][Haskell Platform]] and ensure that the =stack= executable is
on the path.

** Building
Simply run:

#+BEGIN_SRC bash
  stack install --local-bin-path bin
#+END_SRC

to build the binary and put it into a folder in the root of the
project called `bin`.

** Running
Haskell creates native binaries so you can simply run:

#+BEGIN_SRC bash
  ./bin/haskell-bot-exe
#+END_SRC

from the command line to invoke the bot program.

* Project Notes
  :PROPERTIES:
  :ORDERED:  t
  :END:
** DONE Port the starter bot to this RIO app
   CLOSED: [2019-05-01 Wed 09:39]
   :LOGBOOK:
   - CLOSING NOTE [2019-05-01 Wed 09:39] \\
     Important discovery: =liftIO= can be used to bring any standard =IO=
     function into the =RIO Monad= because it's a transformer from =IO=
     already.
   - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 08:49]
   :END:
** DONE Strip out playing logic
   CLOSED: [2019-05-01 Wed 09:44]
   :LOGBOOK:
   - CLOSING NOTE [2019-05-01 Wed 09:44]
   - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 09:41]
   :END:
** DONE Model moves
   CLOSED: [2019-05-01 Wed 13:58]
   :LOGBOOK:
   - CLOSING NOTE [2019-05-01 Wed 13:58]
   - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 10:24]
   :END:
*** DONE Model a map as a single dimensional array
    CLOSED: [2019-05-01 Wed 13:58]
    :LOGBOOK:
    - CLOSING NOTE [2019-05-01 Wed 13:58]
    - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 12:23]
    :END:
**** DONE Model a Cell as an Int
     CLOSED: [2019-05-01 Wed 12:36]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 12:36] \\
       Having things in the same file immediately flagged when I moved the
       size out of the structure because it re-declared the function.
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 12:24]
     :END:
**** DONE Model a Coordinate as an Int
     CLOSED: [2019-05-01 Wed 12:56]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 12:56]
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 12:37]
     :END:
** IN_PROGRESS Implement engine
   :LOGBOOK:
   - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 14:01]
   :END:
*** DONE Model Combined Moves
    CLOSED: [2019-05-01 Wed 14:21]
    :LOGBOOK:
    - CLOSING NOTE [2019-05-01 Wed 14:21]
    - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 14:01]
    :END:
*** DONE Implement =makeMove=
    CLOSED: [2019-06-28 Fri 12:24]
    :LOGBOOK:
    - CLOSING NOTE [2019-06-28 Fri 12:24]
    - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 14:21]
    :END:
**** DONE Make opponent mirror player
     CLOSED: [2019-05-01 Wed 15:14]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 15:14]
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 14:58]
     :END:
**** DONE Make weapon a state level attribute
     CLOSED: [2019-05-01 Wed 15:23]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 15:23]
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 15:15]
     :END:
**** DONE Make =diggingRange= a state level attribute
     CLOSED: [2019-05-01 Wed 15:23]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 15:23]
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 15:17]
     :END:
**** DONE Make =movementRange= a state level attribute
     CLOSED: [2019-05-01 Wed 15:23]
     :LOGBOOK:
     - CLOSING NOTE [2019-05-01 Wed 15:23]
     - State "IN_PROGRESS" from "TODO"       [2019-05-01 Wed 15:17]
     :END:
**** DONE Implement Move
     CLOSED: [2019-06-10 Mon 13:56]
     :LOGBOOK:
     - CLOSING NOTE [2019-06-10 Mon 13:56]
     - State "IN_PROGRESS" from "TODO"       [2019-05-08 Wed 10:37]
     :END:
***** DONE Rule 1: Two do nothings should do nothing
      CLOSED: [2019-05-08 Wed 11:02]
      :LOGBOOK:
      - CLOSING NOTE [2019-05-08 Wed 11:02]
      - State "IN_PROGRESS" from "TODO"       [2019-05-08 Wed 11:02]
      :END:
***** DONE Rule 2: Moving to dirt does not move the worm
      CLOSED: [2019-05-11 Sat 13:05]
      :LOGBOOK:
      - CLOSING NOTE [2019-05-11 Sat 13:05]
      :END:
***** DONE Rule 3: Moving to space does not move the worm
      CLOSED: [2019-05-23 Thu 12:43]
      :LOGBOOK:
      - CLOSING NOTE [2019-05-23 Thu 12:43]
      :END:
***** DONE Rule 4: Moving to air does move the worm
      CLOSED: [2019-05-23 Thu 12:43]
      :LOGBOOK:
      - CLOSING NOTE [2019-05-23 Thu 12:43]
      :END:
***** DONE Rule 5: Moving to the same square causes one of the worms to remain where it is and both to take damage
      CLOSED: [2019-06-02 Sun 11:39]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 11:39]
      - Note taken on [2019-06-02 Sun 10:41] \\
        See rule 8 for the reason that this is being re-worked.
      - State "IN_PROGRESS" from "DONE"       [2019-06-02 Sun 10:41]
      - CLOSING NOTE [2019-05-26 Sun 09:38]
      - State "IN_PROGRESS" from "TODO"       [2019-05-23 Thu 12:52]
      - Note taken on [2019-05-08 Wed 11:05] \\
        This is controlled by the pure value `thisMoveWins' which will only be
        evaluated (creating the random variable) when we need it to adjudicate
        who wins.
      :END:
***** DONE Rule 6: Moving to a square which is occupied by another worm results in no change
      CLOSED: [2019-05-28 Tue 13:10]
      :LOGBOOK:
      - CLOSING NOTE [2019-05-28 Tue 13:10]
      - State "IN_PROGRESS" from "TODO"       [2019-05-26 Sun 09:42]
      :END:
***** DONE Rule 7: Moving to a square which contains a medipack changes that square to air and increases that worms health
      CLOSED: [2019-06-01 Sat 10:48]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-01 Sat 10:48]
      :END:
***** DONE Rule 8: Simultaneous moves to a medipack result in only one worm getting the health from the medipack
      CLOSED: [2019-06-02 Sun 11:39]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 11:39]
      - Note taken on [2019-06-02 Sun 10:39] \\
        I've discovered that this interpretation is not correct.  From the
        rules: Worms will either swap places or stay in their current
        positions (with an equal probability)
      - State "IN_PROGRESS" from "DONE"       [2019-06-02 Sun 10:39]
      - CLOSING NOTE [2019-06-01 Sat 10:58]
      - State "IN_PROGRESS" from "TODO"       [2019-06-01 Sat 10:48]
      :END:
***** DONE Rule 9: Moving off the edge of the map does nothing
      CLOSED: [2019-06-02 Sun 09:18]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 09:18]
      - State "IN_PROGRESS" from "TODO"       [2019-06-01 Sat 17:04]
      :END:
**** DONE Implement Score Changes for Move
     CLOSED: [2019-06-03 Mon 13:07]
***** DONE Rule 1: Moving to dirt penalises your score by 4
      CLOSED: [2019-06-02 Sun 10:21]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 10:21]
      - State "IN_PROGRESS" from "TODO"       [2019-06-02 Sun 09:18]
      :END:
***** DONE Rule 2: Moving to space penalises your score by 4
      CLOSED: [2019-06-02 Sun 10:21]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 10:21]
      - State "IN_PROGRESS" from "TODO"       [2019-06-02 Sun 09:46]
      :END:
***** DONE Rule 3: Moving to an occupied cell penalises your score by 4
      CLOSED: [2019-06-02 Sun 10:21]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 10:21]
      - State "IN_PROGRESS" from "TODO"       [2019-06-02 Sun 09:47]
      :END:
***** DONE Rule 4: Moving to air increases your score by 5
      CLOSED: [2019-06-02 Sun 10:38]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-02 Sun 10:38]
      - State "IN_PROGRESS" from "TODO"       [2019-06-02 Sun 10:21]
      :END:
**** DONE Implement Dig
     CLOSED: [2019-06-07 Fri 11:01]
     :LOGBOOK:
     - CLOSING NOTE [2019-06-07 Fri 11:01]
     :END:
***** DONE Rule 1: Digging air does nothing
      CLOSED: [2019-06-03 Mon 19:22]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-03 Mon 19:22] \\
        This is covered by the fact that my game engine models moving into
        dirt as digging it.  i.e. you cannot command a worm to dig air.
      - State "IN_PROGRESS" from "TODO"       [2019-06-03 Mon 13:07]
      :END:
***** DONE Rule 2: Digging dirt clears the square
      CLOSED: [2019-06-07 Fri 11:00]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-07 Fri 11:00]
      - State "IN_PROGRESS" from "TODO"       [2019-06-03 Mon 19:24]
      :END:
***** DONE Rule 3: Digging space does nothing
      CLOSED: [2019-06-03 Mon 19:23]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-03 Mon 19:23] \\
        This is not possible in my game engine because moving into space is an
        invalid move and moving into dirt is the only way to dig it.
      :END:
**** DONE Implement Score Changes for Digging
     CLOSED: [2019-06-07 Fri 11:17]
     :LOGBOOK:
     - CLOSING NOTE [2019-06-07 Fri 11:17]
     - State "IN_PROGRESS" from "TODO"       [2019-06-07 Fri 11:01]
     :END:
***** DONE Rule 1: Digging air penalises your score by 4
      CLOSED: [2019-06-07 Fri 11:02]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-07 Fri 11:02] \\
        It's not possible to dig into air because moving into air is a valid
        move and the only way to dig is to move into dirt.
      - State "IN_PROGRESS" from "TODO"       [2019-06-07 Fri 11:01]
      :END:
***** DONE Rule 2: Digging dirt increases your score by 7
      CLOSED: [2019-06-07 Fri 11:17]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-07 Fri 11:17]
      - State "IN_PROGRESS" from "TODO"       [2019-06-07 Fri 11:05]
      :END:
***** DONE Rule 3: Digging space penalises your score by 4
      CLOSED: [2019-06-07 Fri 11:02]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-07 Fri 11:02] \\
        It's not possible to dig into space with this engine, because moving
        into dirt is what is considered digging.
      :END:
**** DONE Implement Shoot
     CLOSED: [2019-06-28 Fri 12:24]
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 12:24]
     - State "IN_PROGRESS" from "TODO"       [2019-06-10 Mon 13:58]
     :END:
***** DONE Implement a Scenario Generator and Test It
      CLOSED: [2019-06-25 Tue 18:09]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-25 Tue 18:09]
      - State "IN_PROGRESS" from "TODO"       [2019-06-10 Mon 13:58]
      :END:
****** DONE Implement worms hitting other worms in range scenarios
       CLOSED: [2019-06-10 Mon 13:58]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-10 Mon 13:58]
       - State "IN_PROGRESS" from "TODO"       [2019-06-10 Mon 13:58]
       :END:
****** DONE Implement shots being blocked by dirt or space scenarios
       CLOSED: [2019-06-16 Sun 12:15]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-16 Sun 12:15]
       - State "IN_PROGRESS" from "TODO"       [2019-06-10 Mon 16:06]
       :END:
****** DONE Implement worms blocking other worms
       CLOSED: [2019-06-16 Sun 12:17]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-16 Sun 12:17]
       - State "IN_PROGRESS" from "TODO"       [2019-06-16 Sun 12:16]
       :END:
In this case the first worm should always be hit even if it's
friendly.
****** DONE Change the way that worms are represented
       CLOSED: [2019-06-23 Sun 11:35]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-23 Sun 11:35] \\
         Worms are now represented as ALists of facts where the association is
         between the worm id and it's fact (health or position right now).  The
         representation allows for looking up a worms fact by id or finding the
         worm for which a fact is true.
       - Note taken on [2019-06-16 Sun 12:21] \\
         The new representation is one which associates facts with ids.  The
         games always happen between two teams of three worms so I can get away
         with an alist in which I removed the first element which satisfies the
         given id.  All alists will be of the form (Id, a) where a is one of
         position or health.  The Id will be a bit packed number, with the
         first two bits corresponding to my players three worms and the second
         two bits to the opponents three worms.
       - Note taken on [2019-06-16 Sun 12:18] \\
         It's become obvious that the current representation is difficult to
         work with and prone to creating bugs which are difficult to
         appreciate.
       - State "IN_PROGRESS" from "TODO"       [2019-06-16 Sun 12:18]
       :END:
****** DONE Implement worms being just out of range scenarios
       CLOSED: [2019-06-25 Tue 06:03]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-25 Tue 06:03]
       - State "IN_PROGRESS" from "TODO"       [2019-06-23 Sun 11:36]
       :END:
****** DONE Implement simultaneous shots scenarios
       CLOSED: [2019-06-25 Tue 08:38]
       :LOGBOOK:
       - CLOSING NOTE [2019-06-25 Tue 08:38] \\
         Indicate that work on the simultaneous shots scenario is complete.
       - State "IN_PROGRESS" from "TODO"       [2019-06-24 Mon 09:55]
       :END:
***** DONE Rule 1: A shot hits the first target in range
      CLOSED: [2019-06-25 Tue 18:10]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-25 Tue 18:10]
      :END:
***** DONE Rule 2: A shot hits nothing if nothing is in range in that direction
      CLOSED: [2019-06-25 Tue 18:10]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-25 Tue 18:10]
      :END:
***** DONE Rule 3: A shot is blocked by dirt and deep space
      CLOSED: [2019-06-25 Tue 18:10]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-25 Tue 18:10]
      :END:
***** DONE Rule 4: Worms reduced to zero health are removed from the map
      CLOSED: [2019-06-27 Thu 12:38]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-27 Thu 12:38]
      - State "IN_PROGRESS" from "TODO"       [2019-06-25 Tue 18:10]
      :END:
***** DONE Rule 5: A shot causes x points of damage (Where x is defined in the state file)
      CLOSED: [2019-06-27 Thu 12:38]
      :LOGBOOK:
      - Note taken on [2019-06-27 Thu 12:39] \\
        Hard coded
      - CLOSING NOTE [2019-06-27 Thu 12:38]
      :END:
***** DONE Rule 6: A shots range is d euclidean units (where d is defined in the state file)
      CLOSED: [2019-06-27 Thu 12:38]
      :LOGBOOK:
      - Note taken on [2019-06-27 Thu 12:38] \\
        Hard coded
      - CLOSING NOTE [2019-06-27 Thu 12:38]
      :END:
**** DONE Implement Score Changes for Shoot
     CLOSED: [2019-06-28 Fri 12:24]
     :LOGBOOK:
     - CLOSING NOTE [2019-06-28 Fri 12:24]
     :END:
***** DONE Rule 1: A shot which hits one of your worms penalises your score by 20
      CLOSED: [2019-06-27 Thu 13:01]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-27 Thu 13:01]
      - State "IN_PROGRESS" from "TODO"       [2019-06-27 Thu 12:40]
      :END:
***** DONE Rule 2: A shot which hits an enemy worm increases your score by 20
      CLOSED: [2019-06-28 Fri 06:13]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-28 Fri 06:13]
      - State "IN_PROGRESS" from "TODO"       [2019-06-28 Fri 06:00]
      :END:
***** DONE Rule 3: A shot which knocks an enemy worm unconscious gives you 40
      CLOSED: [2019-06-28 Fri 05:59]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-28 Fri 05:59]
      :END:
***** DONE Rule 4: A shot which hits nothing increases your score by 4
      CLOSED: [2019-06-28 Fri 12:23]
      :LOGBOOK:
      - CLOSING NOTE [2019-06-28 Fri 12:23]
      - State "IN_PROGRESS" from "TODO"       [2019-06-28 Fri 08:35]
      :END:
*** DONE Create Test Harness
    CLOSED: [2019-06-30 Sun 13:24]
    :LOGBOOK:
    - CLOSING NOTE [2019-06-30 Sun 13:24] \\
      I've implemented a test harness and now I need to figure out why my
      bot program fails to simulate the same as theirs.
    - State "IN_PROGRESS" from "TODO"       [2019-06-28 Fri 12:24]
    :END:
*** DONE Implement a failing test for both worms digging out the same block
    CLOSED: [2019-06-30 Sun 13:44]
    :LOGBOOK:
    - CLOSING NOTE [2019-06-30 Sun 13:44] \\
      Was not a problem.
    - Note taken on [2019-06-30 Sun 13:35] \\
      The original note from the source code:

       try to make a move into the space which I just cleared /facepalm
      ctually, that's not the problem because:
      a) I have a test which would fail if it were;
      b) Moving is the first thing which happens;
      c) This would only be a problem if both worms dig out the same
         dirt square at the same time.  This migh
         t result in one worm getting points and not the other.
      I'm going to create a failing test to that effect.
    - State "IN_PROGRESS" from "TODO"       [2019-06-30 Sun 13:29]
    - Note taken on [2019-06-30 Sun 13:27] \\
      My suspicion is that only one will receive points.
    :END:
*** DONE Investigate why my worm moves to a block which was just dug out
    CLOSED: [2019-06-30 Sun 14:31]
    :LOGBOOK:
    - CLOSING NOTE [2019-06-30 Sun 14:31]
    - Note taken on [2019-06-30 Sun 13:57] \\
      The problem is that I move... and then I dig.  So if a player moves
      next to dirt such that if they kept moving then they would dig the
      dirt out, then they get a dig after a move(!)
    - State "IN_PROGRESS" from "TODO"       [2019-06-30 Sun 13:44]
    :END:
*** DONE BUG: When the state ticks over, the next worm is not currently selected
    CLOSED: [2019-07-02 Tue 20:57]
    :LOGBOOK:
    - CLOSING NOTE [2019-07-02 Tue 20:57]
    - State "IN_PROGRESS" from "TODO"       [2019-06-30 Sun 14:34]
    :END:
*** DONE BUG: Medipacks aren't read onto the map correctly
    CLOSED: [2019-07-03 Wed 07:39]
    :LOGBOOK:
    - CLOSING NOTE [2019-07-03 Wed 07:39]
    - State "IN_PROGRESS" from "TODO"       [2019-07-02 Tue 20:59]
    :END:
*** TODO BUG: When collecting a medipack 20 points are not awarded
*** TODO BUG: when knock back would kill a worm their health is instead going negative
    :LOGBOOK:
    - Note taken on [2019-06-30 Sun 13:38] \\
      This works as a test case:

      #+BEGIN_SRC scala
        it "should reward both players and remove dirt when both worms dig the same dirt block" $
          makeMove True (fromMoves digSouthWest digSouth) aStateWithBothWormsNearTheSameDirtBlock `shouldBe`
          (awardPointsToThatPlayerForDigging $
           awardPointsToThisPlayerForDigging $
      #+END_SRC
    - Note taken on [2019-06-30 Sun 13:36] \\
      The solution to this problem is probably to have one function which
      harms worms so that it can encapsulate the idea of a worm dying.
    :END:
** TODO Model search tree type
** TODO Implement search function

* Questions About the Engine
** DONE Do two worms always get to move?  (Or do you miss turns when your other worms die)
   CLOSED: [2019-06-12 Wed 14:10]
   :LOGBOOK:
   - CLOSING NOTE [2019-06-12 Wed 14:10] \\
     Yes.  Worms of an opponent with fewer worms get a chance more
     often.
   :END:
** DONE What id do the remaining worms get when a worm dies
   CLOSED: [2019-06-16 Sun 12:51]
   :LOGBOOK:
   - CLOSING NOTE [2019-06-16 Sun 12:51] \\
     Each player is given a different current worm id because they're given
     different states.  I need to represent the current worm for each
     player rather than as a global thing.
   - State "IN_PROGRESS" from "TODO"       [2019-06-16 Sun 12:46]
   :END:
The engine provides one worm id, but the collections might be of
imbalanced sizes despite the fact that two worms must go at the same
time.
** TODO What the heck is the powerup attribute in the game config
* Potentially Useful, Discarded, Code
In this section I document the code which I wrote and then didn't end
up needing for some or other reason.  Such as having written the code
and then realising that I was doing the wrong thing.

** Worms Predicate
I wrote this worms predicate code for verification on end states, but
then I realised that the kind of stuff that I needed to verify could
be done simply by comparing the previous state to the next state.

#+BEGIN_SRC haskell
  noWormShouldBeHarmed :: Int -> State -> Bool
  noWormShouldBeHarmed originalHealth state =
    allTheseWorms (notHarmed originalHealth) state &&
    allThoseWorms (notHarmed originalHealth) state

  notHarmed :: Int -> Worm -> Bool
  notHarmed originalHealth (Worm _ health' _) =
    health' == originalHealth

  allTheseWorms :: (Worm -> Bool) -> State -> Bool
  allTheseWorms f =
    allWorms f . playersWorms . myPlayer

  allThoseWorms :: (Worm -> Bool) -> State -> Bool
  allThoseWorms f =
    allWorms f . playersWorms . opponent

  allWorms :: (Worm -> Bool) -> Worms -> Bool
  allWorms f = M.foldl' ( \ acc worm -> acc && f worm) True
#+END_SRC

** Checking whether an Id is of a given value
It might be useful to verify the contents of an id to a valid given
id.

#+BEGIN_SRC haskell
  isWormOfId :: Int -> Id -> Bool
  isWormOfId 1  (Id 1)  = True
  isWormOfId 2  (Id 2)  = True
  isWormOfId 3  (Id 3)  = True
  isWormOfId 4  (Id 4)  = True
  isWormOfId 8  (Id 8)  = True
  isWormOfId 12 (Id 12) = True
  isWormOfId _  _       = False
#+END_SRC
* License
Copyright Edward John Steere (c) 2019

Distributed under the GNU General Public License, version 3.
